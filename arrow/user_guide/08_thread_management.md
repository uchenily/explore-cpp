# Thread Management


许多 Arrow C++操作将工作分布在多个线程之间, 以充分利用底层硬件并行性. 例如在读取 Parquet 文件时, 我们可以并行解码每一列. 为了实现这一点, 我们将任务提交给某种 executor.

在 Arrow C++中, 我们使用线程池进行并行调度, 并在用户请求 串行执行时进行事件循环. 用户可以提供自己的自定义实现.(这里没有涉及)


## 线程池
### CPU 与 IO

为了最小化上下文切换的开销, 我们用于 CPU 密集型任务的默认线程池具有固定大小, 默认为`std::thread::hardware_concurrency`, 这意味着 CPU 任务不应该长时间阻塞, 否则会导致 CPU 利用率不足. 为了实现这一点, 我们有一个单独的IO线程池用于需要阻塞的任务.

/O 线程池的大小当前默认为 8 个线程，应根据 I/O 硬件的并行功能调整大小。例如，如果大多数读取和写入发生在典型的 HDD 上，则默认值 8 可能就足够了。另一方面，当大多数读取和写入发生在远程文件系统（如 S3）上时，通常可以从许多并发读取中受益，并且可以通过增加 I/O 线程池的大小来提高 I/O 性能。默认 I/O 线程池的大小可以使用 ARROW_IO_THREADS 环境变量或使用 `arrow::io::SetIOThreadPoolCapacity()` 函数进行管理。

增加 CPU 线程池的大小不太可能带来任何好处。在某些情况下，减小 CPU 线程池的大小可能是有意义的，以减少 Arrow C++ 对与其他进程或用户线程共享的硬件的影响。默认 CPU 线程池的大小可以使用 OMP_NUM_THREADS 环境变量或使用 `arrow::SetCpuThreadPoolCapacity()` 函数进行管理。


### 串行执行

在 Arrow C++ 中可能使用线程的操作通常可以配置为通过某种参数串行运行。在这种情况下，我们通常用由调用线程操作的事件循环替换 CPU executor。但是，许多操作将继续使用 I/O 线程池。这意味着即使请求串行执行，仍可能发生一些并行性。

### Jemalloc 后台线程

使用 jemalloc 分配器时，jemalloc 将创建少量后台线程来管理池。这些线程的影响应该最小，但在运行 Valgrind 等分析工具时，可能会显示为内存泄漏。这是无害的，可以安全地抑制，或者可以在没有 jemalloc 的情况下编译 Arrow C++。

## 异步工具

### Future

Arrow C++ 使用 `arrow::Future`在线程之间传递结果。通常，当操作需要执行某种长时间运行的任务时，将创建一个 `arrow::Future`，该任务将在一段时间内阻塞。`arrow::Future` 对象主要供内部使用，任何返回 `arrow::Future` 的方法通常也会有一个同步变体。
